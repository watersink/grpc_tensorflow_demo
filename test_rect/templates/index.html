<!doctype html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <script src="static/js/tfjs.js"> </script>
    <script src="static/js/tfjs-converter.js"></script>
    <script src="static/js/jquery-1.12.4.min.js"></script>

    <link rel="stylesheet" href="static/css/base.css">

    <!-- jQuery代码 -->
    <script>
        $(function () {
            $(".myChooseFileInput").change(function () {
                // 1.取出选择后的文件名
                var str = $(this).val();
                var arr = str.split('\\');
                var my = arr[arr.length - 1];

                // 2.设置选择的图片内容
                $(".myInputDocNameLabel").html(my);

                // 3.让下面的img渲染出来
                var $file = $(this);
                var fileObj = $file[0];
                var windowURL = window.URL || window.webkitURL;

                var dataURL;
                var $img = $("#cat1");
                var $rightImg = $("#cat");

                if (fileObj && fileObj.files && fileObj.files[0]) {
                    dataURL = windowURL.createObjectURL(fileObj.files[0]);
                    $img.attr('src', dataURL);
                    $rightImg.attr('src',dataURL);

                    // 2.让canvas 清除之前的框
                    clearCanvasRect();

                } else {
                    dataURL = $file.val();
                    var imgObj = document.getElementById("preview");
                    // 两个坑:
                    // 1、在设置filter属性时，元素必须已经存在在DOM树中，动态创建的Node，也需要在设置属性前加入到DOM中，先设置属性在加入，无效；
                    // 2、src属性需要像下面的方式添加，上面的两种方式添加，无效；
                    imgObj.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale)";
                    imgObj.filters.item("DXImageTransform.Microsoft.AlphaImageLoader").src = dataURL;
                }
            });


            // 2.开始按钮的点击事件
            $(".startTestBtn").click(function () {
                // 2.1让底部到图片显示出来
                if ($('.leftImage')[0].src.length > 0) {
                    $(".leftImage").show();
                    $(".rightImage").show();
                    $("#myCanvas").show();

                    // 2.
                    fun();
                } else {
                    $(".leftImage").hide();
                    $(".rightImage").hide();
                }
            });

            // 3.清除canvas之前画的矩形框
            function clearCanvasRect() {
                var canvas = document.getElementById("myCanvas");

                if (canvas.getContext){
                    //
                    var context = canvas.getContext("2d");
                    context.clearRect(0,0,500,500);
                }
            }

        });

    </script>
</head>

<body>

<div class="myTopNav">
    <p class="topGrayText"> 当前正在试用：图片四边形检测（本地识别） <strong></strong> </p>
</div>

<div class="myPane-default">
    <div class="myPanel-heading">
        <label>请上传测试图片:</label>
    </div>
    <br>

    <div class="myInputFileDiv">
        <span class="fileinput_button_span">
            <span>选择图片</span>
            <input class="myChooseFileInput" type="file" accept="image/jpeg,image/png,image" />
        </span>

        <label class="myInputDocNameLabel"> 未选择文件 </label>
    </div>


    <div class="myStartTestDiv">
        <button class="startTestBtn">开始测试</button>
    </div>

</div>

<div class="container">
        <img class="leftImage" id="cat1">
        <img class="rightImage" id="cat">
        <canvas id="myCanvas" width="500" height="500"></canvas>
</div>


<script>
    // 1.
    async function fun(){
        const MODEL_URL = './static/tensorflowjs_model.pb'
        const WEIGHTS_URL = './static/weights_manifest.json'
        const IMAGE_SIZE = 227;

        // 加载模型
         const model = await tf.loadFrozenModel(MODEL_URL, WEIGHTS_URL);


        const imgElement = document.getElementById("cat1");

        // tf.fromPixels() returns a Tensor from an image element.
        const img_tensor = tf.fromPixels(imgElement).toFloat();
        const img_tensor_shape = img_tensor["shape"];


        // resize
        let normalized = tf.image.resizeBilinear(img_tensor,[IMAGE_SIZE,IMAGE_SIZE]);

        // Reshape to a single-element batch so we can pass it to predict.
        const batched = normalized.reshape([1, IMAGE_SIZE, IMAGE_SIZE, 3]);

        // Make a prediction through mobilenet.
        const logits =  model.predict(batched);

        // Convert logits to probabilities and class names.
        // const classes = await getTopKClasses(logits, TOPK_PREDICTIONS);
        const values = await logits.data();


        var x = [];
        var y = [];
        for(let i = 0; i < values.length; i++){
            if (values[i] < 0) {
                values[i] = 0;
            }
            if (values[i] > 1) {
                values[i] = 1;
            }

        if (i % 2 == 0) {
            x.push(values[i] *  img_tensor_shape[1]);
            }
        else {
            y.push(values[i] * img_tensor_shape[0]);
            }
        }

        var canvas = document.getElementById("myCanvas");

        if (canvas.getContext) {
             var context = canvas.getContext("2d");


            // 1.开始路径
            context.beginPath();

            // 2.绘制起点
            context.moveTo(x[0],y[0]);
            context.lineTo(x[1],y[1]);

            // 3.移动到第二个点
            context.lineTo(x[2],y[2]);

            // 4.移动到第三个点
            context.lineTo(x[3],y[3]);

            // 5.移动到第四个点
            context.lineTo(x[0],y[0]);
            context.strokeStyle = "#ff00ff"
            context.lineWidth = 3;
            context.stroke();
    }
}
</script>

</body>

</html>

